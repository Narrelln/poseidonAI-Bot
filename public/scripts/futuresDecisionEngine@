// === futuresDecisionEngine.js ‚Äî Poseidon Deep Learning Trade Engine ===

import { fetchFuturesPrice, fetchVolumeAndOI } from './futuresApiClient.js';
import { updateMemoryFromResult, getMemory } from './updateMemoryFromResult.js';
import { triggerAutoShutdownWithCooldown } from './poseidonBotModule.js';
import { detectTrendPhase } from './trendPhaseDetector.js';
import { openDualEntry } from './ppdaEngine.js';
import { getWalletBalance } from './walletModule.js';
import { logToLiveFeed } from './liveFeedRenderer.js'; // ‚úÖ NEW

// Existing TP logic placeholders...
// TP logic will use determineTP, updateMaxGain, etc. (assume patched externally)

let memory = {};
let failureStreak = 0;
let lossRecoveryMode = false;
let intervalStarted = false;
let tradeCooldown = {};
const MAX_VOLUME_CAP = 20_000_000;
const MIN_VOLUME_CAP = 100_000;
const TRADE_COOLDOWN_MS = 60_000;

const capitalState = {
  total: 0,
  allocated: 0,
  free: 0,
  update(wallet, allocations = []) {
    this.total = wallet.available;
    this.allocated = allocations.reduce((sum, a) => sum + a, 0);
    this.free = Math.max(this.total - this.allocated, 0);
  }
};

function getState(symbol, side) {
  if (!memory[symbol]) memory[symbol] = {};
  if (!memory[symbol][side]) {
    memory[symbol][side] = {
      entryPrice: null,
      lastPrice: null,
      lastEval: 0,
      dcaCount: 0,
      size: 0,
      lastAction: null,
      lastConfidence: null,
    };
  }
  return memory[symbol][side];
}

function isInCooldown(symbol) {
  return Date.now() - (tradeCooldown[symbol] || 0) < TRADE_COOLDOWN_MS;
}

function updateCooldown(symbol) {
  tradeCooldown[symbol] = Date.now();
}

function logDecision(symbol, message) {
  const time = new Date().toLocaleTimeString();
  console.log(`[${time}] ${symbol} ‚Üí ${message}`);
  logToLiveFeed({ symbol, message, type: 'decision' }); // ‚úÖ Log to live feed
}

async function evaluatePoseidonDecision(symbol, signal = null) {
  logDecision(symbol, `üß™ Analyzing ${symbol} (Manual: ${signal?.manual})`);
  if (isInCooldown(symbol)) {
    logDecision(symbol, `‚è≥ Cooldown active ‚Äî skipping ${symbol}`);
    return;
  }

  try {
    const priceData = await fetchFuturesPrice(symbol);
    const price = parseFloat(priceData?.price || 0);
    if (!price || isNaN(price) || price === 0) {
      logDecision(symbol, `‚ö†Ô∏è Invalid price for ${symbol}`);
      return;
    }

    const mem = getMemory(symbol);
    for (const side of ["LONG", "SHORT"]) {
      const m = mem[side];
      if (m.trades >= 8 && m.wins / m.trades < 0.3 && Math.abs(m.currentStreak) > 2) {
        logDecision(symbol, `‚ùå Skipping ${side} ‚Äî cold memory (W:${m.wins}/${m.trades}, Streak:${m.currentStreak})`);
        return;
      }
    }

    let volume = 0;
    try {
      const volumeData = await fetchVolumeAndOI(symbol);
      volume = parseFloat(volumeData?.volume || 0);
    } catch (err) {
      logDecision(symbol, `‚ö†Ô∏è Volume fetch failed: ${err.message}`);
      return;
    }

    if (volume > MAX_VOLUME_CAP && !signal?.override) {
      logDecision(symbol, `‚ùå Skipping ‚Äî too much volume (${(volume / 1e6).toFixed(1)}M)`);
      return;
    }
    if (volume < MIN_VOLUME_CAP) {
      logDecision(symbol, `‚ùå Skipping ‚Äî volume too low (${(volume / 1e3).toFixed(0)}K)`);
      return;
    }

    if (!signal?.manual && signal?.confidence >= 75) {
      const phase = await detectTrendPhase(symbol);
      if (["peak", "reversal"].includes(phase?.phase)) {
        logDecision(symbol, `üîÄ PPDA Trigger ‚Äî ${symbol} (${phase.phase}, C:${signal.confidence})`);
        openDualEntry({ symbol, highConfidenceSide: "SHORT", lowConfidenceSide: "LONG", baseAmount: 1 });
        updateCooldown(symbol);
        return;
      }
    }

    let sides = signal?.forceLong ? ["long"] : ["short"];
    for (const side of sides) {
      if (side === "long" && !signal?.forceLong && !signal?.ppda && !signal?.manual) {
        logDecision(symbol, `üö´ Skipping LONG ‚Äî not high conviction`);
        continue;
      }

      let allowTrade = signal?.manual;
      if (!signal?.manual) {
        const phase = await detectTrendPhase(symbol);
        if (["reversal", "peak"].includes(phase?.phase)) {
          logDecision(symbol, `üìâ Phase: ${phase.phase} (${phase.reasons?.join(', ')})`);
          allowTrade = true;
        } else {
          logDecision(symbol, `‚õî Trend not aligned (${phase?.phase || 'unknown'})`);
        }
      }

      if (!allowTrade) continue;

      const state = getState(symbol, side);
      if (signal?.confidence) state.lastConfidence = signal.confidence;

      if (!state.entryPrice) {
        state.entryPrice = price;
        state.lastPrice = price;
        state.lastEval = Date.now();
        state.dcaCount = 0;
        state.size = 1;
        state.lastAction = "ENTRY";

        let wallet = await getWalletBalance();
        let basePercent = signal?.confidence >= 85 ? 0.25 : 0.10;
        let capital = wallet.available * basePercent;
        capital = Math.min(capital, 250);
        const size = +(capital / price).toFixed(3);

        capitalState.update(wallet, [capital]);
        logDecision(symbol, `üöÄ ${side.toUpperCase()} entry at ${price} (size: ${size})`);

        updateCooldown(symbol);
        continue;
      }

      state.lastPrice = price;
      state.lastEval = Date.now();
      const delta = ((state.entryPrice - price) / state.entryPrice) * 100;

      if (shouldExitTrade(symbol)) {
        markTradeExited(symbol);
        updateMemoryFromResult(symbol, side.toUpperCase(), "win", delta, state.lastConfidence, {
          dcaCount: state.dcaCount,
          tradeType: side,
          time: Date.now()
        });
        logDecision(symbol, `‚úÖ [${side.toUpperCase()}] SMART TP Triggered ‚Äî exiting`);
        state.entryPrice = null;
        state.dcaCount = 0;
        state.size = 1;
        failureStreak = 0;
        if (lossRecoveryMode) {
          lossRecoveryMode = false;
          logDecision(symbol, "üü¢ Exiting recovery mode.");
        }
        continue;
      }

      const TP = 10, DCA = -7;
      const maxDCA = lossRecoveryMode ? 1 : 2;

      if (delta >= TP) {
        updateMemoryFromResult(symbol, side.toUpperCase(), "win", delta, state.lastConfidence, {
          dcaCount: state.dcaCount,
          tradeType: side,
          time: Date.now()
        });
        markTradeExited(symbol);
        logDecision(symbol, `‚úÖ [${side.toUpperCase()}] TAKE PROFIT at +${delta.toFixed(2)}%`);
        state.entryPrice = null;
        state.dcaCount = 0;
        state.size = 1;
        failureStreak = 0;
        if (lossRecoveryMode) {
          lossRecoveryMode = false;
          logDecision(symbol, "üü¢ Exiting recovery mode.");
        }
        continue;
      }

      if (delta <= DCA && state.dcaCount < maxDCA) {
        state.entryPrice = (state.entryPrice * state.size + price) / (state.size + 1);
        state.dcaCount++;
        state.size++;
        updateMemoryFromResult(symbol, side.toUpperCase(), "loss", delta, state.lastConfidence, {
          dcaCount: state.dcaCount,
          tradeType: side,
          time: Date.now()
        });
        logDecision(symbol, `üìâ [${side.toUpperCase()}] DCA at ${delta.toFixed(2)}%`);
        failureStreak++;
        checkFailureStreak();
        continue;
      }

      logDecision(symbol, `[${side.toUpperCase()}] ‚è≥ HOLD ‚Äî Œî ${delta.toFixed(2)}%`);
    }

    const mm = getMemory(symbol);
    logDecision(symbol, `üìä W/L: LONG ${mm.LONG.wins}/${mm.LONG.trades}, SHORT ${mm.SHORT.wins}/${mm.SHORT.trades}`);
  } catch (err) {
    logDecision(symbol, `‚ùå Fatal error: ${err.message}`);
  }
}

function checkFailureStreak() {
  if (failureStreak >= 3) {
    logDecision("SYSTEM", "üî¥ Auto Shutdown ‚Äî 3 consecutive failures");
    triggerAutoShutdownWithCooldown();
    lossRecoveryMode = true;
    failureStreak = 0;
  }
}

function initFuturesDecisionEngine() {
  if (intervalStarted) return;
  intervalStarted = true;
  console.log("‚úÖ Poseidon Engine Initialized");
}

async function getActiveSymbols() {
  try {
    const res = await fetch('/api/scan-tokens');
    const data = await res.json();
    const all = [...data.gainers, ...data.losers].map(t => t.symbol);
    return all;
  } catch (err) {
    console.warn("‚ö†Ô∏è Failed to fetch active symbols:", err.message);
    return [];
  }
}

export {
  evaluatePoseidonDecision,
  initFuturesDecisionEngine,
  getActiveSymbols
};